#!/usr/bin/perl
use strict;
use warnings;
use bigint;
use Find::Lib qw(../lib);
use LogZilla::DebugFilter;
use Log::Fast;
use FindBin;
use LogZilla::Config;
use Getopt::Long;
use File::Basename;
use Cwd qw(abs_path);
use DBI;
use DBD::mysql;
my $ROOT_DIR = abs_path("$FindBin::Bin/..");
use Date::Simple ( 'date', 'today' );
use Date::Parse;
use Date::Format;
use List::Util qw(sum);
use Data::Dumper;
use Socket;
use Excel::Writer::XLSX;
use MIME::Lite;
require 'sys/ioctl.ph';

my $date = Date::Simple->new()->format("%Y-%m-%d");

#FIXME - I had to add below for Perl 5.10 users.
# on Perl 5.10, I would get the following when running:
# perl -e"autoflush STDOUT, 1;"
# Can't locate object method "autoflush" via package "IO::Handle" at -e line 1.
use FileHandle;

# Create default logger, will reconfigure it as soon as we read configuration from database
my $log = Log::Fast->global();

my (@runfuncs);
my $dbh_sphinx;
my @functionlist = ( "countUpdate", "updateHosts", "tblSync", "cleanup_old_views", "cleanup_old_idx", "ss", "idx_rotate", "mtti", "mvdate", "delhost" );
my (@hosts, @cleanup, @tables);

# Command line options
my $options = {
    debug    => 0,
    verbose  => 0,
    verbose  => 0,
    log_file => undef,    # will set default later based on settings in DB
    config_file => "$ROOT_DIR/html/config/config.php",
    help        => 0,
};

sub usage_and_exit {
    my ($exit_code) = @_;

    my $myname = $0;
    $myname =~ s{.*/}{};    # leave just program name without path

    # TODO sync this with getopt
    print STDERR qq{
    This program is used to process incoming syslog messages from a file.
    Usage: $myname [-option -option] 
    -h        : this (help) message
    -d        : debug level (0-5) (0 = disabled [default])
    -dr       : Dry Run (don't make any changes)
    -v        : Also print results to STDERR
    -l        : log file (defaults to dir set in DB settings)
    -r        : Run only specified function(s) (used for debugging)
    -f        : list available functions (for debug use)
    -ss       : Analyze Server Stats [option -mysql]
    -makeview : Creates views in DB for missing dates [usage: ./LZTool -v -r makeview -mvdate '2014-01-01']
    -mvdate   : Used with 'makeview' function to recreate views for old data imports
    -delhost  : Delete a host and all associated records for that host from LogZilla
    -host     : Host to delete from LogZilla
    -rename   : Rename a host (e.g: -rename -renfrom 1.1.1.1 -rento myhost)
    -report   : Run Top 10 Report - Available Types: [Daily/Weekly/Monthly],[Screen/CSV/TSV/Excel] 
    Example: $0 -report D,S -rt P -rt Mne -rt Mac (Daily Report to screen of top Programs, Mnemonics, and MACs)
    Default: $0 -report d (produces a Daily Top 10 report to Screen of Hosts) (-rt assumes Host when left out)
    -rt       : Optional - specify one or more tables to report on, e.g.: -rt Host -rt Program -rt Mac
                Available -rt columns are: Host, Program, Mnemonic, Windows (events), MAC (addresses seen in events) and All (all available columns)
    -topn     : Change Top 10 for -report to another value such as -topn 5
    -mail     : Send Excel-based report as email instead of saving to file
    -mailhost : Set mail host to use for sending emails (default: localhost)
    -mailfrom : Who to send the email from
    -mailto   : Who to send the email to
                Example of -mail Usage: $0 -report d,e -mail -mailhost localhost -mailfrom root\@localhost -mailto someguy\@foo.com
    -saudit   : Show last N searches performed (e.g.: -saudit 10 to show last 10)
    -c        : config file (defaults to $options->{config_file})
    Example: $myname -l /var/log/foo.log -d 5 -c test/config.php -v
    };
    exit($exit_code);
}

GetOptions(
    'debug|d=i'         => \$options->{debug},
    'dryrun|dr'         => \$options->{dryrun},
    'help|h!'           => \$options->{help},
    'verbose|v!'        => \$options->{verbose},
    'log-file|l=s'      => \$options->{log_file},
    'config-file|c=s'   => \$options->{config_file},
    'runfuncs|r=s'      => \@runfuncs,
    'functionlist|f!'   => \$options->{functionlist},
    'idx_rotate!'       => \$options->{idx_rotate},
    'mtti!'             => \$options->{mtti},
    'mysql!'            => \$options->{mysql},
    'mvdate|mvd=s'      => \$options->{mvdate},
    'yes|y'             => \$options->{yes},
    'delhost|dh'        => \$options->{delhost},
    'host=s'            => \@hosts,
    'serversizer|ss'    => \$options->{ss},
    'report=s'          => \$options->{report},
    'rtables|rt=s'      => \@tables,
    'mail!'             => \$options->{mail},
    'mailhost=s'        => \$options->{mailhost},
    'mailfrom=s'        => \$options->{mailfrom},
    'mailto=s'          => \$options->{mailto},
    'host=s'            => \@hosts,
    'saudit=i'          => \$options->{saudit},
    'rename|ren'        => \$options->{rename},
    'renfrom=s'         => \$options->{renfrom},
    'rento=s'           => \$options->{rento},
) or usage_and_exit(1);    # got some invalid options

if ( $options->{help} ) {
    usage_and_exit(0);
}

# Read configuration from (PHP) config file
my $cfg = LogZilla::Config->new( path => $options->{config_file} );

# Connect to DB and setup error handler to log to $log and then exit with error
my $dbh = connect_to_db();

# Read settings from DB.
my $lzsub = 0;
my $svnsub = 0;
my $settings = read_settings_from_db();
my ( $lzmajor, $lzminor )   = split( /\./, $settings->{VERSION} );
( undef,    $lzsub )        = split( /\./, $settings->{VERSION_SUB} );

# Reconfigure log to use log_file (as we finally got it from $settings), also
# set proper level and output based on $options{verbose} and $options{debug}
setup_log();

if ( $options->{dryrun} ) {
    $log->INFO("Dry Run Mode - No modifications will be made");
}

$log->INFO("LogZilla Version $lzmajor.$lzminor.$lzsub" );
$svnsub = `svn info  | grep '^Revision:' | awk '{print \$2}'`;
chomp($svnsub);
my $vdiff = ($svnsub - $lzsub);

$log->ERR("Your version of LogZilla is %s revisions behind, please upgrade using: (cd $settings->{PATH_BASE}/scripts && sudo ./upgrade)", $vdiff) if  ($lzsub < $svnsub);
$log->ERR("Please visit https://www.assembla.com/spaces/LogZillaWiki/wiki/Upgrading for simple instructions") if  ($lzsub < $svnsub);

my ( $results, $rc, $sth, $sth_sphinx, $sql );
my bigint $count;

# calcualating yesterday

my ( $yWeekday, $yYear, $yMonth, $yDay ) = ( localtime( time - 24 * 60 * 60 ) )[ 6, 5, 4, 3 ];
$yYear += 1900;
$yMonth++;

# use 2 digit months and days

$yMonth = sprintf "%02d", $yMonth;
$yDay   = sprintf "%02d", $yDay;

# so the sphinx view of yesterdays data is
my @DoW = qw( Sun Mon Tue Wed Fri Sat );

my $sphinx_yesterday = 'idx_log_arch_day_' . $yYear . $yMonth . $yDay;

if ( defined( $options->{functionlist} ) ) {
    $log->INFO("Available Functions:");
    foreach my $func (@functionlist) {
        $log->INFO("$func");
    }
    exit;
}
$dbh_sphinx = DBI->connect( "DBI:mysql::$settings->{SPX_SRV}:$settings->{SPX_PORT}", 'root', ) || die "Could not connect to SphinxQL: $DBI::errstr";
if ($options->{ss}) {
    ss();
    exit;
}
if ($options->{delhost}) {
    delhost();
    exit;
}
if ($options->{rename}) {
    $log->INFO("Renaming Hostname '%s' to Hostname '%s'", $options->{from}, $options->{to});
    renhost( "$options->{from}", "$options->{to}");
    exit;
}
if ($options->{topn}) {
    topn($options->{topn});
    exit;
}
if ($options->{saudit}) {
    saudit($options->{saudit});
    exit;
}
if ($options->{report}) {
    my ($range, $output) = split (',', $options->{report});
    # Special/hidden from options: Dump configured alerts to csv file
    if ($range =~ /^[Aa]/) { 
	# File saved as /tmp/somefile.csv
		DEBUG(1, "Executing $settings->{PATH_BASE}/scripts/tools/alerts2csv.sh | grep \"File saved as\" | awk '{print \$4}'");
	my $dumpfile = `$settings->{PATH_BASE}/scripts/tools/alerts2csv.sh | grep "File saved as" | awk '{print \$4}'`;
	chomp($dumpfile);
	DEBUG(1, "Dumpfile = $dumpfile");
	if ( $dumpfile ) {
		DEBUG(1, "Running gzip -f $dumpfile");
		system("gzip -f $dumpfile");
		DEBUG(1, "Dump saved as $dumpfile.gz");
		mailto("$dumpfile.gz");
	}
	exit 0;
    }
    $range = "Daily" if ($range !~ /^[Dd]|[Ww]|[Mm]/);
    $output = "Screen" if ($output !~ /[Cc]|[Tt]|[Ee]$/);
    @tables = ("Host") if (!@tables);
    @tables = ("Host", "Program", "Mnemonic", "MAC", "Severity", "Facility") if ($tables[0] =~ /^[Aa]/);
    if ($output =~ /^[Ee]/ ) {
        $log->INFO("Running Excel Report");
        excel($range, @tables);
        exit 0;
    } else {
        report($range, $output, @tables);
        exit 0;
    }
}
if ( $#runfuncs < 0 ) {
    DEBUG( 1, "Running waitfor()");
    waitfor( "indexer", 5, 300 );
    DEBUG( 1, "Running countUpdate()");
    countUpdate();
    DEBUG( 1, "Running updateHosts()");
    updateHosts();
    DEBUG( 1, "Running tblSync(mne)");
    tblSync( "mne",       "mne" );
    DEBUG( 1, "Running tblSync(snare_eid)");
    tblSync( "snare_eid", "eid" );
    DEBUG( 1, "Running tblSync(programs)");
    tblSync( "programs",  "program" );
    DEBUG( 1, "Running cleanup_old_views()");
    cleanup_old_views();
    DEBUG( 1, "Running cleanup_old_idx()");
    cleanup_old_idx();
    DEBUG( 1, "Running mtti()");
    mtti();
} else {
    $log->INFO("Running specific functions only");
    unless ($options->{dryrun}) {
        waitfor( "indexer", 5, 300 );
    }

    foreach my $func (@runfuncs) {
        DEBUG( 1, "Starting $func" );
        if ( $func eq "countUpdate" ) {
            countUpdate();
        }
        elsif ( $func eq "updateHosts" ) {
            updateHosts();
        }
        elsif ( $func eq "tblSync" ) {
            tblSync( "mne",       "mne" );
            tblSync( "snare_eid", "eid" );
            tblSync( "programs",  "program" );
        }
        elsif ( $func eq "cleanup_old_views" ) {
            cleanup_old_views();
        }
        elsif ( $func eq "cleanup_old_idx" ) {
            cleanup_old_idx();
        }
        elsif ( $func eq "idx_rotate" ) {
            idx_rotate();
        }
        elsif ( $func eq "mtti" ) {
            mtti();
        }
        elsif ( $func eq "makeview" ) {
            makeview();
        }
        DEBUG( 1, "Ending $func" );
    }
}

# There should only be subs from here down

sub getYN {
    my ( $prompt, $default ) = @_;
    my $defaultValue = $default ? "[$default]" : "";
    print "$prompt $defaultValue: ";
    chomp( my $input = <STDIN> );
    return $input ? $input : $default;
}

sub tblSync {
    my $db_tbl  = shift;
    my $spx_tbl = shift;
    $log->INFO("Syncing DB->$db_tbl to SP->$spx_tbl...");
    $sql = "update $db_tbl set seen=0, hidden='true'";
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $dbh->do($sql) unless $options->{dryrun};

    if ( $lzminor > 4 ) {
        $sql = "SELECT $spx_tbl, sum(counter), max(lo) from idx_all WHERE match('\@dummy dummy') group by $spx_tbl limit 1000 OPTION max_matches=1000";
    } else {
        $sql = "SELECT $spx_tbl, sum(counter), max(lo) from distributed group by $spx_tbl limit 1000 OPTION max_matches=1000";
    }
    $sth_sphinx = $dbh_sphinx->prepare($sql);
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $sth_sphinx->execute();
    if ( $sth_sphinx->rows > 0 ) {
        $log->INFO( "Found %d ${spx_tbl}s", $sth_sphinx->rows );
        while ( $results = $sth_sphinx->fetchrow_hashref ) {
            $sql = "";
            if ( $db_tbl eq "snare_eid" ) {
                $sql = "update $db_tbl set seen='" . $results->{'sum(counter)'} . "', lastseen=GREATEST(lastseen,from_unixtime('" . $results->{'max(lo)'} . "')), hidden='false' WHERE eid='" . $results->{"$spx_tbl"} . "'";
            } else {
                $sql = "update $db_tbl set seen='" . $results->{'sum(counter)'} . "', lastseen=GREATEST(lastseen,from_unixtime('" . $results->{'max(lo)'} . "')), hidden='false' WHERE crc='" . $results->{"$spx_tbl"} . "'";
            }
            DEBUG( 1, "Executing SQL Statement: $sql" );
            $dbh->do($sql) unless $options->{dryrun};
        }
    }
}

sub cleanup_old_views {

    # cleanup old search results
    my $ts;
    $rc = 'drop view ';
    $sql = "SELECT table_name from information_schema.views WHERE table_name like '%search_results'";
    $sth = $dbh->prepare($sql);
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $sth->execute();
    while ( $results = $sth->fetchrow_hashref ) {
        # cdukes: #466 - Added TS check for expired view names 
        DEBUG(1, "Checking expire date on %s", $results->{'table_name'});
        ( $ts ) = split( /_/, $results->{'table_name'} );
        my $expire = (time() - 86400);
        DEBUG(1, "View TS = %d, Current TS = %d", $ts, $expire);
        if ($ts < $expire) { 
            $rc = $rc . $results->{'table_name'};
            $rc = $rc . ",";
        } else {
            DEBUG(1, "View %s will not be removed because it does not expire until %s", $results->{'table_name'}, time2str("%D", $ts) );
        }
    }
    $rc = substr( $rc, 0, -1 );
    if ( $rc !~ /^drop view$/ ) {
        DEBUG( 1, "Executing SQL Statement: '$rc'" );
        $dbh->do($rc) unless $options->{dryrun};
    }
}

sub countUpdate {
    $log->INFO("Collecting Counts");

    # Preparing replacement for updateCache db procedure: Count all counters
    # due to a bug in sphinxql when using sum you also need to use a group-by
    if ( $lzminor > 4 ) {
        $sql = "SELECT severity, sum(counter) from idx_all WHERE match('\@dummy dummy') group by severity limit 0,100 OPTION max_matches=1000";
    } else {
        $sql = "SELECT severity, sum(counter) from distributed group by severity limit 50000 OPTION max_matches=1000";
    }
    DEBUG( 1, "Preparing SQL Statement: $sql" );
    $sth_sphinx = $dbh_sphinx->prepare($sql);
    $sth_sphinx->execute();
    $count = 0;

    # Print number of rows found
    if ( $sth_sphinx->rows == 0 ) {
        $log->INFO("No data found, do you have any log data?");
        exit;
    } else {
        $log->INFO( "Verifying msg_sum cache", $sth_sphinx->rows );
        my $spx_total = $dbh_sphinx->do('SELECT * from idx_all WHERE MATCH(\'@dummy dummy\') limit 1');
        my $spx_meta  = $dbh_sphinx->prepare('show meta');
        $spx_meta->execute();
        while ( $results = $spx_meta->fetchrow_hashref ) {
            if ( $results->{'Variable_name'} eq "total_found" ) {
                $log->INFO("There are %s indexed events", commify( $results->{'Value'} ));
                $count = $results->{'Value'};
                $sth = $dbh->prepare('REPLACE INTO cache (name,value,updatetime) VALUES ("msg_sum",?,NOW());');
                $sth->execute($count) unless $options->{dryrun};
                store_metric( "lztool_msgsum", $count );
            }
        }

    }

    # Check yesterday's counters
    $sql = "show tables like '$sphinx_yesterday'";
    DEBUG( 1, "Preparing SQL Statement: $sql" );
    $sth = $dbh->prepare($sql);
    $sth->execute();
    if ( $sth->rows == 0 ) {
        DEBUG( 1, "No index for $sphinx_yesterday, no need to update counts..." );
    } else {
        if ( $lzminor > 4 ) {
            $sql = "SELECT severity, sum(counter) from $sphinx_yesterday WHERE match('\@dummy dummy') group by severity";
        } else {
            $sql = "SELECT severity, sum(counter) from $sphinx_yesterday group by severity";
        }
        DEBUG( 1, "Preparing SQL Statement: $sql" );
        $sth_sphinx = $dbh_sphinx->prepare($sql);
        $sth_sphinx->execute();
        $count = 0;
        while ( $results = $sth_sphinx->fetchrow_hashref ) {
            $count = $count + $results->{'sum(counter)'};
        }
        if ( $count > 0 ) {
            my $cache_yesterday_statistics = 'chart_mpd_' . $yYear . "-" . $yMonth . "-" . $yDay . "_" . $DoW[$yWeekday];
            $log->INFO("Updating $cache_yesterday_statistics with $count");
            $sql = "REPLACE INTO cache (name,value,updatetime) VALUES ('$cache_yesterday_statistics',$count,NOW())";
            DEBUG( 1, "Executing SQL Statement: $sql" );
            $dbh->do($sql) unless $options->{dryrun};
        }
    }
}

sub updateHosts {
    my $table = shift;
    $sql = "update hosts set seen=0, hidden='true'";
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $dbh->do($sql) unless $options->{dryrun};

# Note that DB's with host count > 5000 may be a problem here. This needs testing.
    if ( $lzminor > 4 ) {
        $sql = "SELECT host_crc, sum(counter), max(lo) from idx_all WHERE match('\@dummy dummy') group by host_crc limit 50000 OPTION max_matches=1000";
    } else {
        $sql = "SELECT host_crc, sum(counter), max(lo) from distributed group by host_crc limit 50000 OPTION max_matches=1000";
    }
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $dbh_sphinx->do($sql);
    my $sth_sphinx = $dbh_sphinx->prepare($sql);
    $sth_sphinx->execute();
    if ( $sth_sphinx->rows > 0 ) {
        $log->INFO( "Updating %d hosts...", $sth_sphinx->rows );
        store_metric( "lztool_hostcount", sprintf( "%d", $sth_sphinx->rows ) );
        while ( my $results = $sth_sphinx->fetchrow_hashref ) {
            $sql = ( "update hosts set seen=" . $results->{'sum(counter)'} . ", lastseen=GREATEST(lastseen,from_unixtime(" . $results->{'max(lo)'} . ")), hidden='false' WHERE crc32(host)=" . $results->{'host_crc'} );
            DEBUG( 1, "Executing SQL Statement: $sql" );
            $dbh->do($sql) unless $options->{dryrun};
        }
        $log->INFO("Searching for dropped hosts...");
        $sql = "SELECT value from settings WHERE name='RETENTION_DROPS_HOSTS'";
        $sth = $dbh->prepare($sql);
        DEBUG( 1, "Executing SQL Statement: $sql" );
        $sth->execute();
        if ( ( $sth_sphinx->rows ) < 0 ) {
            $log->ERR("RETENTION_DROPS_HOST not found in SETTINGS");
        } else {
            $results = $sth->fetchrow_hashref;
            if ( ( $results->{'value'} ) == 1 ) {
                $log->INFO("RETENTION_DROPS_HOST found. Dropping hidden hosts");
                $sql = "delete from hosts WHERE hidden='true'";
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $dbh->do($sql) unless $options->{dryrun};
            }
        }
    }
}

$sth_sphinx->finish if defined( ($sth_sphinx) );
$sth->finish if defined( ($sth) );
$dbh_sphinx->disconnect();
$dbh->disconnect();

# =================================================================================================
# Helper functions
# =================================================================================================

sub humanBytes {
    my $size = shift;
    $size = $size * 1024;    # incoming numbers are in kilobytes already
    if ( $size > 1099511627776 )    #   TiB: 1024 GiB
    {
        return sprintf( "%.2f TiB", $size / 1099511627776 );
    }
    elsif ( $size > 1073741824 )    #   GiB: 1024 MiB
    {
        return sprintf( "%.2f GiB", $size / 1073741824 );
    }
    elsif ( $size > 1048576 )       #   MiB: 1024 KiB
    {
        return sprintf( "%.2f MiB", $size / 1048576 );
    }
    elsif ( $size > 1024 )          #   KiB: 1024 B
    {
        return sprintf( "%.2f KiB", $size / 1024 );
    }
    else                            #   bytes
    {
        return "$size byte" . ( $size == 1 ? "" : "s" );
    }
}

sub HumanToBytes {
    my @strings = @_;
    my $base    = 1024;
    my %units   = (
        K => $base,
        M => $base**2,
        G => $base**3,
        T => $base**4,
        P => $base**5,
        E => $base**6,
        Z => $base**7,
        Y => $base**8,
    );
    my $pattern = join( '|', sort keys %units );
    my $total;
    for my $string (@strings) {
        while ( $string =~ /(([0-9]*(?:\.[0-9]+)?)($pattern))/g ) {
            my $number = $2 * $units{$3};
            $total += $number;
            DEBUG( 1, "Converting %12s to %12.0f", $1, $number );
        }
    }
    return sprintf "%.0f", $total;
}
sub humanReadable {
    my $int = shift;
    my $exp = 0;
    my $units = [qw(K M B T Q)];
    for (@$units) {
        last if $int < 1000000;
        $int /= 1000000;
        $exp++;
    }
    return wantarray ? ($int, $units->[$exp]) : sprintf("%.2f%s", $int, $units->[$exp]);
}

sub commify {
    my $text = reverse $_[0];
    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text;
}

sub mean {
    return @_ ? sum(@_) / @_ : 0
}

sub sec2human {
    my $secs = shift;
    if ( $secs >= 365 * 24 * 60 * 60 ) { return sprintf '%.1f Years', $secs / ( 365 * 24 * 60 * 60 ) }
    elsif ( $secs >= 24 * 60 * 60 ) { return sprintf '%.1f Days', $secs / ( 24 * 60 * 60 ) }
    elsif ( $secs >= 60 * 60 ) { return sprintf '%.1f Hours', $secs / ( 60 * 60 ) }
    elsif ( $secs >= 60 ) { return sprintf '%.1f Minutes', $secs / (60) }
    else                  { return sprintf '%.1f Seconds', $secs }
}

sub connect_to_db {
    my $dbh = DBI->connect( $cfg->db_dsn, $cfg->db_user, $cfg->db_pass,
        { HandleError => sub { $log->ERR( $_[0] ); exit(1) } } );
    $dbh->{TraceLevel} = $options->{dbi_debug};
    return $dbh;
}

# Create hash with pairs of name => value for every row read from settings table
sub read_settings_from_db {
    my %settings;
    my $sth = $dbh->prepare("SELECT name, value FROM settings");
    $sth->execute();
    while ( my $r = $sth->fetchrow_arrayref ) {
        $settings{ $r->[0] } = $r->[1];
    }
    $settings{SNARE} = 0 if $settings{SNARE} != 1;
    return \%settings;
}

sub setup_log {
    my $log_dir = $settings->{PATH_LOGS};

    # Create log dir, and build log path if not provided by command line option
    if ( !-d $log_dir ) {
        mkdir( $log_dir, 0755 ) or croak("mkdir $log_dir: $!");
    }
    if ( !$options->{log_file} ) {
        $options->{log_file} = $log_dir . "/" . basename( $0, '.pl' ) . '.log';
    }

    my $log_options = {};

    # Set up output to file or both file and stderr
    if ( $options->{verbose} ) {

        # make multiplexer FH sending data both to file and STDERR
        open( my $fh, '>>:tee', $options->{log_file}, \*STDERR )
            or croak("$options->{log_file}: $!");
        $fh->autoflush(1);
        $log_options->{fh} = $fh;
    }
    else {
        open( my $fh, '>>', $options->{log_file} ) or croak("$options->{log_file}: $!");
        $log_options->{fh} = $fh;
    }

# Setup extra information to put in every log line, depending on debug level
    if ( $options->{debug} > 1 ) {
        $log_options->{prefix} = "%D %T %S [%L] ";
    }
    else {
        $log_options->{prefix} = "%D %T [%L] ";
    }

    $log_options->{level} = $options->{debug} > 0 ? 'DEBUG' : 'INFO';

    $log->config($log_options);

    $SIG{__WARN__} = sub {
        my $msg = shift;
        $msg =~ s/\n//;
        $log->WARN($msg);
    };

    my $int = `cat /proc/net/route | sort -t' ' -nk3 | awk '{print \$1}' | head -1`;
    chomp($int);
    my $ip = getIf($int);
    chomp(my $hostname = `hostname`);
    $log->INFO("Program initialized successfully");
    $log->INFO("[$hostname/$ip] Starting logging to $options->{log_file} with pid $$");
}

sub DEBUG {
    my ( $level, @log_args ) = @_;
    if ( $options->{debug} >= $level ) {
        $log->DEBUG(@log_args);
    }
}

sub cleanup_old_idx {
    $log->INFO("Starting cleanup of old index files..");
    my $basepath  = $settings->{PATH_BASE};
    my $datadir   = "$basepath/sphinx/data";
    my $retention = $settings->{RETENTION};
    DEBUG( 1, "Index Data Path is $datadir" );
    my ( $year, $mon, $day ) = ( localtime( time - ( 24 * $retention ) * 60 * 60 ) )[ 5, 4, 3 ];
    $year += 1900;
    $mon++;
    $mon = sprintf "%02d", $mon;
    $day = sprintf "%02d", $day;
    my $old_idx = 'idx_log_arch_day_' . $year . $mon . $day;
    DEBUG( 1, "DB Retention level set to $retention days" );
    DEBUG( 1, "Oldest index is $old_idx" );
    $log->INFO("Removing indexes older than $retention days");
    DEBUG( 1, "Running system command: for file in `find $datadir/idx_log_arch_day_* -type f -mtime +$retention 2>/dev/null`; do echo \"removing \$file\"; rm \$file; done" );
    system("for file in `find $datadir/idx_log_arch_day_* -type f -mtime +$retention 2>/dev/null`; do echo \"removing \$file\"; rm \$file; done") unless $options->{dryrun};

    # cleanup old indexes from views
    my @views;
    $log->INFO("Pruning old archive views");
    $sql = "SELECT table_name from information_schema.views WHERE table_name like 'log_arch_day_%'";
    $sth = $dbh->prepare($sql);
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $sth->execute();
    if ( $sth->rows > 0 ) {

        while ( $results = $sth->fetchrow_hashref ) {
            my ( undef, undef, undef, $yymmdd ) = split( /_/, $results->{'table_name'} );
            my $date = today();
            my $diff = today() - date($yymmdd);
            DEBUG( 1, "Date = $date, Diff = $diff day(s)" );
            if ( $diff > $retention ) {
                $log->INFO("Adding view $results->{'table_name'} as drop candidate because it is older than $retention days");
                push( @views, $results->{'table_name'} );
            }
        }
        if (@views) {
            foreach my $view (@views) {
                $log->INFO("Dropping view: $view");
                $sql        = "drop view $view";
                $sth = $dbh->prepare($sql);
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
            }
        } else {
            $log->INFO("No old views found");
        }
    } else {
        $log->INFO("No old views left for cleanup");
    }
}

sub idx_rotate {
    $log->INFO("-=Analyzing Index Archives=-");
    my ( $speed, $events );
    my $memdays = $settings->{SPX_IDX_DIM};
    my $php     = `which php`;
    chomp $php;
    DEBUG( 1, "Running $php $ROOT_DIR/sphinx/sphinx.conf | grep \"^index idx_log_arch_day\" | awk '{print \$2}' | awk -F'_' '{print \$5\"_\"\$6 }' | uniq" );
    my @list = `$php $ROOT_DIR/sphinx/sphinx.conf | grep "^index idx_log_arch_day" | awk '{print \$2}' | awk -F'_' '{print \$5"_"\$6}' | uniq`;
    my @indexlist;

    foreach my $item (@list) {
        chomp($item);
        my ( $day, $part ) = split /_/, $item;
        next if $day !~ /\d+/;
        next if $part !~ /\d+/;
        DEBUG(1, "Processing $item for day $day, part $part");
        my $date = today();
        my $diff = today() - date($day);
        # No need to go back more than 3 days as it is highly unlikely that the indexes would be stored in memory that far back.
        # This helps speed up nightly rotate on larger servers.
        if ($diff >= 3) {
            $log->INFO("Skipping processing of $day since it is $diff days old and should not need to be rotated");
            #@list = grep { $_ ne $item } @list;
        } else {
            $log->INFO("Checking Index ($day, part $part)");
            DEBUG( 1, "Running command: $ROOT_DIR/sphinx/bin/indextool --config $ROOT_DIR/sphinx/sphinx.conf --dumpheader idx_log_arch_day_${day}_$part | grep docinfo | awk '{print \$2}'" );
            my $docinfo = `$ROOT_DIR/sphinx/bin/indextool --config $ROOT_DIR/sphinx/sphinx.conf --dumpheader idx_log_arch_day_${day}_$part | grep docinfo | awk '{print \$2}'`;
            chomp($docinfo);

            if ($docinfo) {
                DEBUG( 1, "Docinfo is $docinfo" );
                DEBUG( 1, "Running command: $ROOT_DIR/sphinx/bin/indextool --config $ROOT_DIR/sphinx/sphinx.conf --dumpheader idx_log_arch_day_${day}_0 | grep total-documents | awk '{print \$2}'" ); 
                $events = `$ROOT_DIR/sphinx/bin/indextool --config $ROOT_DIR/sphinx/sphinx.conf --dumpheader idx_log_arch_day_${day}_0 | grep total-documents | awk '{print \$2}'`;
                # cdukes: Ticket #511 - For some reason, the if statement below was incorrect - as if someone had joined it with the previous line.
                if ( $events ) {
                    chomp($events);
                    DEBUG(1, "Calculated Date for Today is $date");
                    DEBUG(1, "Date diff for determining whether to convert to disk-based storage");
                    DEBUG(1, "Calculated Docinfo = $docinfo, Calculated Diff = $diff, Calculated memdays = $memdays");

                    #DEBUG(1, "If docinfo = extern (memory-based storage) and diff > memdays, then convert to disk-based storage (docinfo=inline)");
                    DEBUG(1, "If docinfo = extern (memory-based storage) and diff > memdays, then convert to disk-based storage (ondisk_attrs=1)");
                    #if ( ( $diff > $memdays ) && ( $docinfo =~ /extern/ ) ) {
                    if ( ( $diff > $memdays ) && ( $docinfo =~ /ondisk_attrs\s+=\s+0/ ) ) {
                        $log->INFO("The $day index is $diff day(s) older than today.");
                        #$log->INFO("Converting index (${day}_$part) to disk-based storage (docinfo=inline) because it is > $memdays day(s) old...");
                        $log->INFO("Converting index (${day}_$part) to disk-based storage (ondisk_attrs=1) because it is > $memdays day(s) old...");
                        push( @indexlist, "idx_log_arch_day_${day}_$part" );
                    }

                    # cdukes: added below in case someone changes their idx_mem_days in the db and we need to go back and convert disk based indexes back to memory based
                    #DEBUG(1, "If docinfo = inline (disk-based storage) and diff <= memdays, then convert to memory-based storage (docinfo=extern)");
                    DEBUG(1, "If ondisk_attrs=1 (disk-based storage) and diff <= memdays, then convert to memory-based storage (ondisk_attrs=0)");
                    # if ( ( $diff <= $memdays ) && ( $docinfo =~ /inline/ ) ) {
                    if ( ( $diff <= $memdays ) && ( $docinfo =~ /ondisk_attrs\s+=\s+1/ ) ) {
                        $log->INFO("The $day index is $diff day(s) older than today.");
                        #$log->INFO("Converting index (${day}_$part) to memory-based storage (docinfo=extern) because it is <= $memdays day(s) old and your SPX_IDX_DIM is set to $memdays");
                        $log->INFO("Converting index (${day}_$part) to memory-based storage (ondisk_attrs=0) because it is <= $memdays day(s) old and your SPX_IDX_DIM is set to $memdays");
                        push( @indexlist, "idx_log_arch_day_${day}_$part" );
                    }
                }
            } else {
                $log->ERR( "Unable to obtain DOCINFO from the index header for idx_log_arch_day_${day}_$part, you will need to manually run '%s' to find out why", "$ROOT_DIR/sphinx/bin/indextool --config $ROOT_DIR/sphinx/sphinx.conf --dumpheader idx_log_arch_day_${day}_$part" );
            }
        }
    }
    if (@indexlist) {

        # guess at sphinx's indexing speed on this server
        $speed = 12000;
        my $idxcnt = sprintf( "%.0f", scalar(@indexlist) );
        my $secs   = sprintf( "%.0f", $events / $speed * $idxcnt );
        DEBUG( 1, "events = $events, speed = $speed, indexcount = $idxcnt" );
        $log->INFO( "This may take about %s (just a non-scientific guess)", sec2human($secs) );

# cdukes: have to move this to a loop, looks like doing them all at once is too much for large scale
# instead, we will call idx_rotate every hour so that these get re-indexed one at a time
#my $indexes = join( ' ', @indexlist );
#DEBUG( 1, "Running $ROOT_DIR/sphinx/bin/indexer --config $ROOT_DIR/sphinx/sphinx.conf $indexes --rotate --sighup-each" );
#system("$ROOT_DIR/sphinx/bin/indexer --config $ROOT_DIR/sphinx/sphinx.conf $indexes --rotate --sighup-each") unless $options->{dryrun};
        foreach my $index (@indexlist) {
            DEBUG( 1, "Running $ROOT_DIR/sphinx/bin/indexer --config $ROOT_DIR/sphinx/sphinx.conf $index --rotate" );
            system("$ROOT_DIR/sphinx/bin/indexer --config $ROOT_DIR/sphinx/sphinx.conf $index --rotate") unless $options->{dryrun};
        }
    }
    $log->INFO("Completed index checks");

}

sub ss {
    $log->INFO("-=Analyzing LogZilla Server Stats=-");
    $sql = "SELECT count(*) as count FROM hosts";
    $sth = $dbh->prepare($sql);
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $sth->execute();
    $results = $sth->fetchrow_hashref;
    my $hostcount = $results->{count};
    # $sql = "SELECT AVG(ROUND(count)) as avg, count(*) as samples FROM events_per_second";
    $sql = "SELECT AVG(ROUND(count)) as avg, count(*) as samples FROM events_per_second WHERE ts_from >= UNIX_TIMESTAMP(NOW() - INTERVAL 1 WEEK)";
    $sth = $dbh->prepare($sql);
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $sth->execute();
    $results = $sth->fetchrow_hashref;
    my ($eps, $eph, $epd);

    if ( ( $results->{'avg'} ) > 1 ) {

        #---
        # Memory Stats
        #---
        $log->INFO("Memory Stats...");
        my $spmem = `(cd $ROOT_DIR/sphinx/data && du -hsck *.spa *.spe *.sph *.spi *.spk *.spl *.spm *.sps | grep total | awk '{print \$1}')`;
        chomp($spmem);
        DEBUG( 1, "spmem = %s", $spmem );
        $results->{avg} = sprintf( "%0.f", $results->{avg} );
        $log->INFO( "Your current EPS average is %s (%s samples)", commify( $results->{avg} ), commify( $results->{samples} ) );
        store_metric( "lztool_eps_avg",         $results->{avg} );
        store_metric( "lztool_eps_avg_samples", $results->{samples} );
        $eps = $results->{avg};
        $eph = $results->{avg} * 60 * 60;
        $epd = $results->{avg} * 60 * 60 * 24;
        my $attrs = `cat $ROOT_DIR/sphinx/sphinx.conf | grep sql_attr | grep -v "#" | wc -l`;

        $sql        = "SELECT count(*) AS count FROM events_per_hour";
        $sth = $dbh->prepare($sql);
        DEBUG( 1, "Executing SQL Statement: $sql" );
        $sth->execute();
        $results = $sth->fetchrow_hashref;
        if ( ( $results->{'count'} ) > 1 ) {
            $log->INFO( "LogZilla uptime is %s hours", $results->{count} );
            store_metric( "lztool_srv_uptime_hours", $results->{count} );
        } else {
            $log->INFO("Sorry, there's no data available yet. Is this a new installation?");
            exit;
        }
        my $multiplier = $settings->{SPX_IDX_DIM} + 2;  # needed for current day
        # Search-time memory requirements for ondisk_attrs=0 storage are (1+number_of_attrs)*number_of_docs*4 bytes, ie. 10 million docs with 2 groups and 1 timestamp will take (1+2+1)*10M*4 = 160 MB of RAM. This is PER DAEMON, ie. searchd will alloc 160 MB on startup, read the data and keep it shared between queries; the children will NOT allocate additional copies of this data.
        my $count = 0;
        my $tmp = $dbh_sphinx->do('SELECT * from idx_inmem limit 1');
        my $spx_meta  = $dbh_sphinx->prepare('show meta');
        $spx_meta->execute();
        while ( $results = $spx_meta->fetchrow_hashref ) {
            if ( $results->{'Variable_name'} eq "total_found" ) {
                $count = $results->{'Value'};
            }
        }
        chomp ($attrs);
        my $needed = ((( 3 + $attrs ) * ($count * 4  / 1000)) * $multiplier);
        DEBUG( 1, "(1 + %s Attributes) * %s Messages in idx_inmem * 4 = $needed", $attrs, $count);
        $log->INFO( "Expecting %s average EPD from %s hosts", commify($epd), commify($hostcount) );
        store_metric( "lztool_epd", $epd );
        my $total = `cat /proc/meminfo | grep MemTotal | awk '{print \$2}'`;
        chomp($total);
        my $free = `cat /proc/meminfo | grep MemFree | awk '{print \$2}'`;
        chomp($free);
        my $cached = `cat /proc/meminfo | grep ^Cached | awk '{print \$2}'`;
        chomp($cached);
        $log->INFO( "You have %s total system memory", humanBytes($total) );
        $log->INFO( "You have %s free system memory",  humanBytes($free) );
        $log->INFO( "You have %s memory Cached (available for use)",  humanBytes($cached) );
        $log->INFO( "Your server is configured to store %d extra day(s) of events in memory (the rest on disk)", $settings->{SPX_IDX_DIM} );
        $log->INFO( "The LogZilla indexer is using %s RAM to store indexed information in memory - note that this is only for the indexer and not for system resources or MySQL", humanBytes($spmem) );
        #$log->INFO( "LogZilla is currently using %s of that %s total.", humanBytes($spmem), humanBytes($needed) );
        store_metric( "lztool_idx_memused", $spmem );
        store_metric( "lztool_mem_total",   $total );
        store_metric( "lztool_mem_free",    $free );
        store_metric( "lztool_mem_cached",  $cached );
        store_metric( "lztool_spx_dim",     $settings->{SPX_IDX_DIM} );
        store_metric( "lztool_mem_needed",  $needed );
        my $remainder = ($free + $cached) - ( $needed - $spmem );

        if ( ($remainder) < 0 ) {
            $remainder = -$remainder;
            $log->WARN("You don't have enough memory to support this logging level!");
            $log->INFO( "You need at least %s more Ram", humanBytes($remainder) );
        }

        #---
        # Disk Stats
        #---
        $log->INFO("Disk Stats...");
        my $dbsize_kbytes = 0;
        my $spdsk = `(cd $ROOT_DIR/sphinx/data && du -hsck *.spd *.spe *.sph *.spi *.spk *.spl *.spm *.spp *.sps | grep total | awk '{print \$1}')`;
        chomp($spdsk);
        my $du = $spdsk; # define du here in case the only disk usage is from today (server only up for one day)
        $log->INFO( "Current Index Size (on disk) is approximately %s", humanBytes($spdsk) );
        store_metric( "lztool_index_diskused_KB", $spdsk );
        $sql = "SELECT table_schema, Round(Sum(data_length + index_length) / 1024, 0) AS 'dbsize_kbytes' FROM information_schema.tables WHERE table_schema='syslog' GROUP  BY table_schema";
        $sth = $dbh->prepare($sql);
        DEBUG( 1, "Executing SQL Statement: $sql" );
        $sth->execute();
        $results = $sth->fetchrow_hashref;
        $dbsize_kbytes = $results->{'dbsize_kbytes'};
        $log->INFO( "Current DB size (on disk) is approximately %s", humanBytes( $dbsize_kbytes ) );
        store_metric( "lztool_db_diskused_KB", $dbsize_kbytes );

# below doesn't work because events/sec don't drop for data > $retention
# $sql = "SELECT FROM_UNIXTIME(ts_from) as dt, ts_from AS ts FROM events_per_second limit 1";
        $sql = "SELECT UNIX_TIMESTAMP(fo) AS ts, fo AS dt FROM logs ORDER BY lo ASC LIMIT 1";
        $sql = "SELECT (SELECT UNIX_TIMESTAMP(max(lo)) from logs) as ts, (SELECT min(fo) from logs) as fo, (SELECT max(lo) from logs) as lo";
        $sth = $dbh->prepare($sql);
        DEBUG( 1, "Executing SQL Statement: $sql" );
        $sth->execute();
        $results = $sth->fetchrow_hashref;
        my $db_numdays = 0;

        if ( ( $results->{'ts'} ) > 1 ) {
            my $date = today();
            my ( $ymd, undef ) = split( /\s+/, $results->{fo} );
            $db_numdays = today() - date($ymd) + 1; # Note: add +1 here to include today in the disk usage calculation
            DEBUG( 1, "YMD = %s, DB->fo = %s, DB->lo = %s, DB->ts = %s, Date = %s, Diff = %s", $ymd, $results->{fo}, $results->{lo}, $results->{ts}, $date, $db_numdays );
            if ( $db_numdays < 2 ) {
                $log->WARN("Results may not be accurate, please run this tool after your server has been running for > 2 days");
            }
            $du = sprintf( "%d", ( $spdsk / $db_numdays ) );
            DEBUG( 1, "spdisk = %s, db_numdays = %s, du = %s", $spdsk, $db_numdays, $du );
            $log->INFO( "LogZilla indexes (excluding MySQL) should consume about %s of disk per day.", humanBytes($du) );
            $log->INFO( "MySQL should consume about %s of disk per day.", humanBytes($dbsize_kbytes / $db_numdays) );
            store_metric( "lztool_estimated_disk_perday", "$du" );
        }

        #---
        # MySQL Helper
        #---
        if ( $options->{mysql} ) {
            $log->INFO("MySQL Analysis...");
            $sql = "SELECT CONCAT(ROUND(KBS/POWER(1024,IF(pw<0,0,IF(pw>3,0,pw)))+0.49999), SUBSTR(' KMG',IF(pw<0,0,IF(pw>3,0,pw))+1,1)) recommended_innodb_buffer_pool_size FROM (SELECT SUM(index_length) KBS FROM information_schema.tables WHERE engine='InnoDB') A,(SELECT 3 pw) B;";
            $sth = $dbh->prepare($sql);
            DEBUG( 1, "Executing SQL Statement: $sql" );
            $sth->execute();
            $results = $sth->fetchrow_hashref;
            my $recommended_innodb_buffer_pool_size = $results->{'recommended_innodb_buffer_pool_size'};
            $sql = "SELECT CONCAT(ROUND(KBS/POWER(1024,IF(pw<0,0,IF(pw>3,0,pw)))+0.49999), SUBSTR(' KMG',IF(pw<0,0,IF(pw>3,0,pw))+1,1)) recommended_key_buffer_size FROM (SELECT SUM(index_length) KBS FROM information_schema.tables WHERE engine='MyISAM' AND table_schema NOT IN ('information_schema','mysql')) A, (SELECT 3 pw) B";
            $sth = $dbh->prepare($sql);
            DEBUG( 1, "Executing SQL Statement: $sql" );
            $sth->execute();
            $results = $sth->fetchrow_hashref;
            my $recommended_key_buffer_size = $results->{'recommended_key_buffer_size'};
            $log->INFO( "The recommended innodb_buffer_pool_size for this server is %s", $recommended_innodb_buffer_pool_size );
            $log->INFO( "The recommended key_buffer_size for this server is %s", $recommended_key_buffer_size );
            store_metric( "lztool_innodb_rec", HumanToBytes("$recommended_innodb_buffer_pool_size") );
            store_metric( "lztool_myisam_rec", HumanToBytes("$recommended_key_buffer_size") );
        }
    } else {
        $log->INFO("Sorry, there's no EPS data avilable yet. Is this a new installation?");
    }
}

sub renhost {
    # Performs a renaming of one host to another.
    # Used for renaming an IP to a hostname
    my ( $orig, $new ) = @_;
    my $seen =0;

    # First get the count of $orig 
    $log->INFO("Collecting info on $orig");
    $sql = "SELECT seen FROM hosts WHERE host='$orig'";
    $sth = $dbh->prepare($sql);
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $sth->execute();
    $results = $sth->fetchrow_hashref;
    if ( $results->{'seen'} > 0 ) {
        $seen=$results->{'seen'};
        $log->INFO( "Found %d occurrences of $orig...", $seen );

        # Rename $orig to $new in the logs table
        $log->INFO("Performing rename from $orig to $new on logs table");
        $sql = "UPDATE logs set host='$new' WHERE host='$orig'";
        $sth = $dbh->prepare($sql);
        DEBUG( 1, "Executing SQL Statement: $sql" );
        $sth->execute() unless $options->{dryrun};

        $log->INFO("Updating count for $new in the hosts table");
        $sql = "INSERT into hosts (host, seen, lastseen) VALUES ('$new', $seen, NOW()) ON DUPLICATE KEY UPDATE lastseen=NOW(), seen=seen+$seen";
        $sth = $dbh->prepare($sql);
        DEBUG( 1, "Executing SQL Statement: $sql" );
        $sth->execute() unless $options->{dryrun};

        # Remove $orig from the hosts table
        $log->INFO("Removing $orig from hosts table");
        $sql = "DELETE from hosts WHERE host='$orig'";
        $sth = $dbh->prepare($sql);
        DEBUG( 1, "Executing SQL Statement: $sql" );
        $sth->execute() unless $options->{dryrun};
    } else {
        $log->INFO("There are no hosts in the DB named $orig");
    }
}

sub mtti {
    $log->INFO("-=Calculating MTTI Stats=-");
    $sql = "SELECT FROM_UNIXTIME(ts_start) AS start, FROM_UNIXTIME(ts_end) AS end, value FROM sph_metrics WHERE name='indexer' ORDER BY ts_start DESC limit 5000";
    $sth = $dbh->prepare($sql);
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $sth->execute();
    my @vals;
    while ( $results = $sth->fetchrow_hashref ) {
        my $diff = str2time( $results->{end} ) - str2time( $results->{start} );
        DEBUG( 2, "diff between %s and %s is %s", $results->{start}, $results->{end}, sec2human($diff) );
        push( @vals, $results->{value} );
    }
    if (@vals) {
        my $int = sprintf "%d", mean(@vals);
        $log->INFO( "Mean Time To Index is %d seconds (%s samples)", $int, commify( scalar(@vals) ) );
        store_metric( "lztool_mtti", $int );
    } else {
        $log->INFO("Sorry, there's no data available yet. Is this a new installation?");
    }
}

sub store_metric {
    my ( $name, $value ) = @_;

    #$log->INFO("Storing Metrics: $name = $value");
    DEBUG( 1, "Storing Metrics: $name = $value" );
    $sql = "INSERT INTO sph_metrics (name,value,ts_start,ts_end) VALUES ('$name', $value, UNIX_TIMESTAMP(NOW()), UNIX_TIMESTAMP(NOW()))";
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $dbh->do($sql) unless $options->{dryrun};
}

sub waitfor {

    # Need to wait for indexer to finish if it is restarting searchd
    my ( $proc, $sleepfor, $timelimit ) = @_;
    my $i = 0;
    DEBUG( 1, "Running ps -C $proc -o pid=" );
    my $pid = `ps -C $proc -o pid=`;
    DEBUG( 1, "PID = $pid" );
    while ($pid) {
        chomp $pid;
        $log->INFO("$0: Waiting up to $timelimit seconds for $proc on PID $pid to finish...");
        if ( $i >= $timelimit ) {
            $log->INFO("$0: Timed out waiting for $proc on PID $pid");
            exit;
        }
        sleep $sleepfor;
        $pid = `ps -C $proc -o pid=`;
        $i += $sleepfor;
    }
}

sub makeview {
    my $ymd = $options->{mvdate};
    my ( $y, $m, $d );
    if ($ymd) {
        if ( $ymd =~ /(\d{4})-?(\d{2})-?(\d{2})-?/ ) {
            my $y = $1;
            my $m = $2;
            my $d = $3;
            $log->INFO("Creating view name log_arch_day_$y$m$d");
            $sql = "CREATE OR REPLACE VIEW log_arch_day_$y$m$d AS SELECT `logs`.`id` AS `id`,`logs`.`host` AS `host`,`logs`.`facility` AS `facility`,`logs`.`severity` AS `severity`,`logs`.`program` AS `program`,`logs`.`msg` AS `msg`,`logs`.`mne` AS `mne`,`logs`.`eid` AS `eid`,`logs`.`suppress` AS `suppress`,`logs`.`counter` AS `counter`,`logs`.`fo` AS `fo`,`logs`.`lo` AS `lo`,`logs`.`notes` AS `notes` FROM `logs` WHERE ((`logs`.`fo` >= '$ymd 00:00:00') AND (`logs`.`fo` <= '$ymd 23:59:59'))";
            DEBUG( 1, "Executing SQL Statement: $sql" );
            $dbh->do($sql) unless $options->{dryrun};
            $sql = "SELECT table_name FROM INFORMATION_SCHEMA.tables WHERE table_type = 'VIEW' AND table_schema = 'syslog' AND table_name LIKE 'log_arch_day_$y$m$d%'";
            $sth = $dbh->prepare($sql);
            DEBUG( 1, "Executing SQL Statement: $sql" );
            $sth->execute();

            while ( $results = $sth->fetchrow_hashref ) {
                $log->INFO("Creating view_limits for log_arch_day_$y$m$d");
                $sql = "REPLACE INTO view_limits (view_name, min_id, max_id) values ('$results->{table_name}', IFNULL((SELECT min(id) FROM $results->{table_name}),1), IFNULL((SELECT max(id) FROM $results->{table_name}),1))";
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $dbh->do($sql) unless $options->{dryrun};
                $log->INFO("View creation complete");
                unless ( $options->{yes} ) {
                    my $ok = &getYN( "Data will be unavailable until indexed. Should I index the new data?", "y" );
                    if ( $ok =~ /[Yy]/ ) {
                        my $cores = $settings->{SPX_CPU_CORES};
                        for ( my $i = 0 ; $i < $cores ; $i++ ) {
                            system("cd $ROOT_DIR/sphinx && bin/indexer  idx_log_arch_day_$y$m${d}_$i --rotate");
                        }
                    }
                } else {
                    my $cores = $settings->{SPX_CPU_CORES};
                    for ( my $i = 0 ; $i < $cores ; $i++ ) {
                        system("cd $ROOT_DIR/sphinx && bin/indexer  idx_log_arch_day_$y$m${d}_$i --rotate");
                    }
                }
            }
        } else {
            $log->ERR("Option -mvdate must be in the form YYYY-MM-DD");
        }
    } else {
        $log->ERR("Option 'makeview' requires a date in the form YYYY-MM-DD");
    }
}
sub delhost {
    my %prgs = ();
    my %mnes = ();
    my %eids = ();
    my %hosthash = ();
    my %prghash = ();
    my %mnehash = ();
    my %eidhash = ();
    my ($sth, $id, $host, $prg, $mne, $eid, $seen, $seenfloor);
    my $hostscsv = join("','", @hosts);
    $log->INFO("-=Calculating events associated with Hosts=-");
    $sql = "SELECT * FROM logs WHERE host IN ('$hostscsv')";
    $sth = $dbh->prepare($sql);
    DEBUG( 1, "Executing SQL Statement: $sql" );
    $sth->execute();
    while ( $results = $sth->fetchrow_hashref ) {
        $id      = $results->{id};
        $host    = $results->{host};
        $prg     = $results->{program};
        $mne     = $results->{mne};
        $eid     = $results->{eid};
        $seen    = $results->{counter};
        $hosthash{$host}{seen} += $seen;   
        $prghash{$prg}{seen} += $seen;   
        $mnehash{$mne}{seen} += $seen;   
        $eidhash{$eid}{seen} += $seen;   
    }

    if (%hosthash) {
        while( my ($host) = each %hosthash ) {
            $seen = $hosthash{$host}{seen};
            $log->INFO("Processing %s events from $host", commify($seen));
            if ($seen > 0) {
# Update message count
                $sql = "SELECT value AS seen FROM cache WHERE name='msg_sum'";
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
                while ( $results = $sth->fetchrow_hashref ) {
                    $seenfloor  = $results->{seen};
                    $seen   = $seenfloor if ($seen>$seenfloor); # Don't allow $seen to be < 0
                }
                $sql = "UPDATE cache set value=value-$seen WHERE name='msg_sum'";
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
            }
        }
        while( ($prg) = each %prghash ) {
            $seen = $prghash{$prg}{seen};
            if ($seen > 0) {
# Update program count
                $sql = "SELECT seen FROM programs WHERE crc='$prg'";
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
                while ( $results = $sth->fetchrow_hashref ) {
                    $seenfloor  = $results->{seen};
                    $seen   = $seenfloor if ($seen>$seenfloor); # Don't allow $seen to be < 0
                }
                if ($seen == $seenfloor) {
                    $sql = "DELETE FROM programs WHERE crc='$prg'";
                    $log->INFO("Removing all associateds entries from Programs->$prg", commify($seen));
                } else {
                    $sql = "UPDATE programs set seen=seen -$seen WHERE crc='$prg'";
                    $log->INFO("Removing %s entries from Programs->$prg", commify($seen));
                }
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
            } else {
                $log->INFO("Removing Programs->$prg");
                $sql = "DELETE FROM programs WHERE crc='$prg'";
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
            }
        }

        while( ($mne) = each %mnehash ) {
            $seen = $mnehash{$mne}{seen};
# Update mne count
            if ($seen > 0) {
                $sql = "SELECT seen FROM mne WHERE crc='$mne'";
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
                while ( $results = $sth->fetchrow_hashref ) {
                    $seenfloor  = $results->{seen};
                    $seen   = $seenfloor if ($seen>$seenfloor); # Don't allow $seen to be < 0
                }
                if ($seen == $seenfloor) {
                    $sql = "DELETE FROM mne WHERE crc='$mne'";
                    $log->INFO("Removing all associated entries from Mnemonics->$mne", commify($seen));
                } else {
                    $sql = "UPDATE mne set seen=seen -$seen WHERE crc='$mne'";
                    $log->INFO("Removing %s entries from Mnemonics->$mne", commify($seen));
                }
                $log->INFO("Removing %s entries from Mnemonics->$mne", commify($seen));
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
            } else {
                $log->INFO("Removing Mnemonics->$mne");
                $sql = "DELETE FROM mne WHERE crc='$mne'";
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
            }
        }

        while( ($eid) = each %eidhash ) {
            $seen = $eidhash{$eid}{seen};
# Update eid count
            if ($seen > 0) {
                $sql = "SELECT seen FROM snare_eid WHERE eid='$eid'";
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
                while ( $results = $sth->fetchrow_hashref ) {
                    $seenfloor  = $results->{seen};
                    $seen   = $seenfloor if ($seen>$seenfloor); # Don't allow $seen to be < 0
                }
                if ($seen > $seenfloor) {
                    $sql = "DELETE FROM snare_eid WHERE eid='$eid'";
                    $log->INFO("Removing all associated entries from Windows EventIDs->$eid", commify($seen));
                } else {
                    $sql = "UPDATE snare_eid set seen=seen -$seen WHERE eid='$eid'";
                    $log->INFO("Removing %s entries from Windows EventIDs->$eid", commify($seen));
                }
                $log->INFO("Removing %s entries from Windows EventIDs->$eid", commify($seen));
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
            } else {
                $log->INFO("Removing EID->$eid");
                $sql = "DELETE FROM snare_eid WHERE eid='$eid'";
                $sth = $dbh->prepare($sql) unless $options->{dryrun};
                DEBUG( 1, "Executing SQL Statement: $sql" );
                $sth->execute() unless $options->{dryrun};
            }

        }
# Remove from logs
        $log->INFO("Removing hosts from Logs table");
        $sql = "DELETE FROM logs WHERE host IN ('$hostscsv')";
        $sth = $dbh->prepare($sql) unless $options->{dryrun};
        DEBUG( 1, "Executing SQL Statement: $sql" );
        $sth->execute() unless $options->{dryrun};
    } else {
        foreach $host (@hosts) {
            $log->INFO("$host has no associated events, removing from hosts table...");
            $sql = "DELETE FROM hosts WHERE host='$host'";
            $sth = $dbh->prepare($sql) unless $options->{dryrun};
            DEBUG( 1, "Executing SQL Statement: $sql" );
            $sth->execute() unless $options->{dryrun};
        }
    }
# Cleanup/Sync counts
#countUpdate();
#updateHosts();
#tblSync( "mne",       "mne" );
#tblSync( "snare_eid", "eid" );
#tblSync( "programs",  "program" );
}
sub getIf {
    my ($iface) = @_;
    my $socket;
    socket($socket, PF_INET, SOCK_STREAM, (getprotobyname('tcp'))[2]) || warn "Sub 'getIf' is unable to create a socket: $!\n";
    my $buf = pack('a256', $iface);
    if (ioctl($socket, SIOCGIFADDR(), $buf) && (my @address = unpack('x20 C4', $buf))) {
        return join('.', @address);
    }
    return undef;
}
sub report {
    my $range = shift;
    my $output = shift;
    my @tables = @_;
    my $lastseen = "";
    $log->INFO("-=Running Reports=-");
    $options->{topn} = 10 if (!$options->{topn});
    foreach my $table (@tables) {
	    my $name = "";
	    if ($table =~ /^[Hh]/) {
		    $table = "Hosts";
		    $sql = "SELECT host AS name,seen,lastseen FROM hosts GROUP BY host ORDER BY seen DESC limit $options->{topn}";
		    $sth = $dbh->prepare($sql);
	    }
	    if ($table =~ /^[Mm][Nn]/) {
		    $table = "Mnemonics";
		    $sql = "SELECT name,seen,lastseen FROM mne WHERE name !='None' GROUP BY name ORDER BY seen DESC limit $options->{topn}";
		    $sth = $dbh->prepare($sql);
	    }
	    if ($table =~ /^[Pp]/) {
		    $table = "Programs";
		    $sql = "SELECT name,seen,lastseen FROM programs GROUP BY name ORDER BY seen DESC limit $options->{topn}";
		    $sth = $dbh->prepare($sql);
	    }
	    if ($table =~ /^[Mm][Aa]/) {
		    $table = "MACs";
		    $sql = "SELECT name,seen,lastseen FROM mac GROUP BY name ORDER BY seen DESC limit $options->{topn}";
		    $sth = $dbh->prepare($sql);
	    }
	    if ($table =~ /^[Ww]/) {
		    $table = "Windows Events";
		    $sql = "SELECT eid AS name,seen,lastseen FROM snare_eid GROUP BY name ORDER BY seen DESC limit $options->{topn}";
		    $sth = $dbh->prepare($sql);
	    }
	    if ($table =~ /^[Ss]/) {
		    $table = "Severities";
		    $sql = "SELECT sum(counter) as seen, severity, lo FROM idx_inmem GROUP BY severity ORDER BY seen DESC limit $options->{topn}";
		    $sth = $dbh_sphinx->prepare($sql);
	    }
	    if ($table =~ /^[Ff]/) {
		    $table = "Facilities";
		    $sql = "SELECT sum(counter) as seen, facility, lo FROM idx_inmem GROUP BY facility ORDER BY seen DESC limit $options->{topn}";
		    $sth = $dbh_sphinx->prepare($sql);
	    }
	    printf ("\n%-25s %-20s %-20s\n", "$table", "Last Seen", "# of Times Seen") if ($output =~ /^[Ss]/);
	    printf "$table,Last Seen,Times Seen\n" if ($output =~ /^[Cc]/);
	    printf "$table\tLast Seen\tTimes Seen\n" if ($output =~ /^[Tt]/);
	    DEBUG( 1, "Executing SQL Statement: $sql" );
	    $sth->execute();
	    while ( $results = $sth->fetchrow_hashref ) {
		    $name = $results->{name} if ($results->{name});
		    $lastseen = $results->{lastseen} if ($results->{lastseen});
		    $name = $dbh->selectrow_array("SELECT name FROM facilities WHERE code='$results->{facility}'") if ($table =~ /^[Ff]/);
		    $name = $dbh->selectrow_array("SELECT name FROM severities WHERE code='$results->{severity}'") if ($table =~ /^[Ss]/);
		    $lastseen = $dbh->selectrow_array("SELECT FROM_UNIXTIME($results->{lo})") if ($results->{lo});
		    my $seen = $results->{seen};
		    printf ("%-25s %-20s %-20s\n", $name, $lastseen, commify($seen)) if ($output =~ /^[Ss]/);
		    printf "$name,$lastseen,$seen\n" if ($output =~ /^[Cc]/);
		    printf "$name\t$lastseen\t$seen\n" if ($output =~ /^[Tt]/);
	    }
    }
}
sub excel {
	my $range = shift;
	my @tables = @_;
	$options->{topn} = 10 if (!$options->{topn});
	my ($workbook, $worksheet, $headings, $data, $chart);
	my $fn = "/tmp/LogZilla-Report-$date.xlsx";
	my ($name, $lastseen);
	$workbook  = Excel::Writer::XLSX->new( "$fn" );
	my $headerCol1 = $workbook->add_format(); 
	my $headerCol2 = $workbook->add_format(); 
	my $col1Format = $workbook->add_format(); 
	my $col2Format = $workbook->add_format(); 
	$headerCol1->set_bold();
	$headerCol2->set_bold();
	$headerCol2->set_align('right');
	# Sets format as text
	$col1Format->set_num_format('@'); 
	$col2Format->set_num_format('#,##0');
	$col2Format->set_align('right');
	$log->INFO("-=Creating Excel Report=-");
	foreach my $table (@tables) {
		if ($table =~ /^[Hh]/) {
			$table = "Hosts";
			$sql = "SELECT host AS name,seen,lastseen FROM hosts GROUP BY host ORDER BY seen DESC limit $options->{topn}";
			$sth = $dbh->prepare($sql);
		}
		if ($table =~ /^[Mm][Nn]/) {
			$table = "Mnemonics";
			$sql = "SELECT name,seen,lastseen FROM mne WHERE name !='None' GROUP BY name ORDER BY seen DESC limit $options->{topn}";
			$sth = $dbh->prepare($sql);
		}
		if ($table =~ /^[Pp]/) {
			$table = "Programs";
			$sql = "SELECT name,seen,lastseen FROM programs GROUP BY name ORDER BY seen DESC limit $options->{topn}";
			$sth = $dbh->prepare($sql);
		}
		if ($table =~ /^[Mm][Aa]/) {
			$table = "MAC Addresses";
			$sql = "SELECT name,seen,lastseen FROM mac GROUP BY name ORDER BY seen DESC limit $options->{topn}";
			$sth = $dbh->prepare($sql);
		}
		if ($table =~ /^[Ww]/) {
			$table = "Windows Events";
			$sql = "SELECT eid AS name,seen,lastseen FROM snare_eid GROUP BY name ORDER BY seen DESC limit $options->{topn}";
			$sth = $dbh->prepare($sql);
		}
		if ($table =~ /^[Ss]/) {
			$table = "Severities";
			$sql = "SELECT sum(counter) as seen, severity, lo FROM idx_inmem GROUP BY severity ORDER BY seen DESC limit $options->{topn}";
			$sth = $dbh_sphinx->prepare($sql);
		}
		if ($table =~ /^[Ff]/) {
			$table = "Facilities";
			$sql = "SELECT sum(counter) as seen, facility, lo FROM idx_inmem GROUP BY facility ORDER BY seen DESC limit $options->{topn}";
			$sth = $dbh_sphinx->prepare($sql);
		}
		$worksheet = $workbook->add_worksheet("$table");
		$worksheet->write( 'A1', $table, $headerCol1 );
		$worksheet->write( 'B1', "Seen", $headerCol2 );
		DEBUG( 1, "Executing SQL Statement: $sql" );
		$sth->execute();
		my $rownum = 2; 
		my $c1width = (length($table) + 1);
		my $c2width = (length("Seen") + 3); # Yeah, I could have just set this to 4, but we may make this variable later :)
			while ( $results = $sth->fetchrow_hashref ) {
				$name = $results->{name} if ($results->{name});
				$lastseen = $results->{lastseen} if ($results->{lastseen});
				$name = $dbh->selectrow_array("SELECT name FROM facilities WHERE code='$results->{facility}'") if ($table =~ /^[Ff]/); 
				$name = $dbh->selectrow_array("SELECT name FROM severities WHERE code='$results->{severity}'") if ($table =~ /^[Ss]/);
				$name =~ s/:/-/g if ($table =~ /^[Mm][Aa]/); 
				DEBUG(1, "$name - $table - $results->{seen} - SELECT name FROM facilities WHERE code='$results->{facility}'") if ($results->{facility});
				$lastseen = $dbh->selectrow_array("SELECT FROM_UNIXTIME($results->{lo})") if ($results->{lo});
				$worksheet->write_string("A$rownum", "$name", $col1Format);
				$worksheet->write("B$rownum", $results->{seen}, $col2Format);
				$c1width = length($name) if $c1width < (length($name) + 1);
				$c2width = (length($results->{seen}) + 3) if $c2width < (length($results->{seen}) + 3);
				$rownum++;
			}
		$worksheet->set_column(0, 0,  $c1width); 
		$worksheet->set_column(1, 1,  $c2width); 
		$chart = $workbook->add_chart( type => 'pie', embedded => 1 );
# Configure the series.
		$rownum--;
		$chart->add_series(categories=>"=$table".'!$A$2:$A$'.$rownum,values=>"=$table".'!$B$2:$B$'.$rownum,name=>"Top $options->{topn} ${table}");
# Add a title.
		$chart->set_title( name => "Top $options->{topn} ${table}" );
# Insert the chart into the worksheet.
		$worksheet->insert_chart( 'D2', $chart, 0, 10 );
	}
	$workbook->close();
	if ($options->{mail}) {
		mailto($fn);
	} else {
		printf "File saved as $fn\n";
	}
}
sub saudit {
	$log->INFO("-=Last %d Searches=-", $options->{saudit});
	$sql = "SELECT user,string,seen,from_unixtime(lastseen_ts) as lastseen FROM saudit ORDER BY lastseen_ts DESC limit $options->{saudit}";
	$sth = $dbh->prepare($sql);
	DEBUG( 1, "Executing SQL Statement: $sql" );
	$sth->execute();
	printf("\n%-10s %-25s %-8s %-80s\n", "Username", "Time Stamp", "Count", "Search Term");
	while ( $results = $sth->fetchrow_hashref ) {
		my $user  = $results->{user};
		my $string  = $results->{string};
		my $seen  = $results->{seen};
		my $lastseen  = $results->{lastseen};
		printf("%-10s %-25s %-8s %-80s\n", $user, $lastseen, commify($seen), $string);

	}
}
sub mailto {
	my $fn = shift;
	my ($range, undef) = split (',', $options->{report});
	$range = "Dumpfile" if ($range =~ /^[Aa]/);
	$range = "Daily" if ($range =~ /^[Dd]/);
	$range = "Weekly" if ($range =~ /^[Ww]/);
	$range = "Monthly" if ($range =~ /^[Mm]/);
	$log->INFO("Sending $fn");
	my $body = "Here's your $range LogZilla Report for $date";
	my $sig = "Sincerely,\nThe LogZilla Teami\nhttp://www.logzilla.net\n\t\t    __\n\t\t   / *_) Rawr!\n\t  _.----. _ /../\n\t/.............../\n        __/...(....|.(....|\n       /__.--.|_|--|_|\n";
	my $hn = `hostname`;
	chomp ($hn);
        $options->{mailhost} = "localhost" if (!$options->{mailhost});
        $options->{mailfrom} = "$hn\@logzilla.net" if (!$options->{mailfrom});
        $options->{mailto} = "servers\@logzilla.net" if (!$options->{mailto});
	my $subject = "[$hn] LogZilla $range Report";
### Start with a simple text message:
	my $mail = MIME::Lite->new(
			'From'          => $options->{mailfrom},
			'To'            => $options->{mailto},
			'Subject'       => "$subject",
			'Type'          => 'multipart/mixed',
			);
	$mail->attach(
			'Type'          => 'TEXT',
			'Data'          => "$body\n\n$sig",
		     );
	$mail->attach(
#'Type'          => 'application/vnd.ms-excel',
			#'Type'          => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
			'Type'          => 'application/zip',
			Path => $fn,
			Disposition => 'attachment',
		     ) or die "Error adding $fn: $!\n";
# DEBUG(1, $mail->send('smtp',$options->{mailhost}, Debug=>1 )) 
	$mail->send('smtp', $options->{mailhost});
}
